<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ivan's Birthday Pooper</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <style>
      /* CSS for 8-bit style */
      body {
        background-color: #202020;
        color: #fff;
        font-family: "Press Start 2P", cursive;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        overflow: hidden;
      }
      #game-container {
        width: 800px;
        height: 600px;
        background-color: #000;
        border: 4px solid #fff;
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
      }
      .screen {
        display: none;
        text-align: center;
        width: 100%;
      }
      .screen.active {
        display: block;
      }
      h1 {
        color: #ff0055;
        text-shadow: 4px 4px #00ffcc;
        font-size: 40px;
        margin-bottom: 60px;
        line-height: 1.5;
      }
      .menu-item {
        font-size: 24px;
        margin: 20px 0;
        color: #fff;
        cursor: pointer;
      }
      .menu-item.selected {
        color: #ffff00;
      }
      .menu-item.selected::before {
        content: "â–º ";
        color: #ffff00;
      }
      .game-over {
        color: #ff0000;
        font-size: 60px;
        text-shadow: 4px 4px #550000;
      }
      .happy-birthday {
        color: #00ff00;
        font-size: 40px;
        text-shadow: 4px 4px #005500;
        animation: blink 1s infinite;
      }
      @keyframes blink {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }
      .instruction {
        position: absolute;
        bottom: 20px;
        font-size: 12px;
        color: #666;
        width: 100%;
        text-align: center;
      }
      #game-canvas {
        background-color: #111;
        image-rendering: pixelated;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <!-- Start Screen -->
      <div id="start-screen" class="screen active">
        <h1>IVAN'S BIRTHDAY<br />POOPER</h1>
        <div style="margin-bottom: 40px; color: #00ccff">ARE YOU IVAN?</div>
        <div class="menu-item selected" data-value="yes">YES</div>
        <div class="menu-item" data-value="no">NO</div>
        <div class="instruction">USE ARROW KEYS AND ENTER</div>
      </div>

      <!-- Level 1 Screen -->
      <div id="level1-screen" class="screen">
        <canvas id="game-canvas" width="760" height="520"></canvas>
        <div class="instruction">ARROWS TO MOVE â€¢ SPACE TO POO</div>
      </div>

      <!-- Game Over Screen -->
      <div id="game-over-screen" class="screen">
        <h1 class="game-over">GAME OVER</h1>
        <p id="game-over-reason">ONLY IVAN CAN PLAY</p>
        <p style="font-size: 12px; margin-top: 50px; color: #666">
          REFRESH TO TRY AGAIN
        </p>
      </div>

      <!-- Success Screen -->
      <div id="success-screen" class="screen">
        <h1 class="happy-birthday">HAPPY BIRTHDAY<br />IVAN!</h1>
        <p style="color: #ffff00; margin-top: 30px">LEVEL 1 CLEARED</p>
      </div>
    </div>

    <script>
      // JavaScript for game logic
      const startScreen = document.getElementById("start-screen");
      const gameOverScreen = document.getElementById("game-over-screen");
      const gameOverReason = document.getElementById("game-over-reason");
      const successScreen = document.getElementById("success-screen");
      const level1Screen = document.getElementById("level1-screen");
      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");

      const menuItems = document.querySelectorAll(".menu-item");
      let selectedIndex = 0;
      let gameRunning = false;
      let animationId;

      // Game Constants
      const TILE_SIZE = 40;
      const COLS = 19;
      const ROWS = 13;

      // Game State
      let hero = {};
      let enemies = [];
      let bombs = [];
      let explosions = [];
      let walls = [];
      let keys = {};

      // Menu Logic
      function updateSelection() {
        menuItems.forEach((item, index) => {
          if (index === selectedIndex) {
            item.classList.add("selected");
          } else {
            item.classList.remove("selected");
          }
        });
      }

      document.addEventListener("keydown", (e) => {
        if (startScreen.classList.contains("active")) {
          if (e.key === "ArrowUp" || e.key === "ArrowDown") {
            selectedIndex = selectedIndex === 0 ? 1 : 0;
            updateSelection();
          } else if (e.key === "Enter") {
            const selectedValue =
              menuItems[selectedIndex].getAttribute("data-value");
            startScreen.classList.remove("active");
            if (selectedValue === "yes") {
              initGame();
            } else {
              showGameOver("ONLY IVAN CAN PLAY");
            }
          }
        } else if (gameRunning) {
          keys[e.key] = true;
          if (e.key === " ") {
            placeBomb();
          }
        }
      });

      document.addEventListener("keyup", (e) => {
        if (gameRunning) {
          keys[e.key] = false;
        }
      });

      function showGameOver(reason) {
        gameRunning = false;
        level1Screen.classList.remove("active");
        gameOverReason.innerText = reason;
        gameOverScreen.classList.add("active");
      }

      // Game Logic
      function initGame() {
        level1Screen.classList.add("active");
        gameRunning = true;

        // Reset State
        // Smaller hitbox (28) for easier navigation in 40px tiles
        const offset = (TILE_SIZE - 28) / 2;
        hero = {
          x: TILE_SIZE + offset,
          y: TILE_SIZE + offset,
          w: 28,
          h: 28,
          speed: 3,
          color: "#FFD700",
          name: "IVAN",
          emoji: "ðŸ˜Ž",
          dead: false,
        };
        enemies = [
          {
            x: (COLS - 2) * TILE_SIZE + offset,
            y: (ROWS - 2) * TILE_SIZE + offset,
            w: 28,
            h: 28,
            speed: 1,
            color: "#00FF00",
            name: "OLEG",
            emoji: "ðŸ¤“",
            dead: false,
            dir: 0,
            moveTimer: 0,
          },
          {
            x: TILE_SIZE + offset,
            y: (ROWS - 2) * TILE_SIZE + offset,
            w: 28,
            h: 28,
            speed: 1,
            color: "#0000FF",
            name: "PAVEL",
            emoji: "ðŸ‘¹",
            dead: false,
            dir: 0,
            moveTimer: 0,
          },
          {
            x: (COLS - 2) * TILE_SIZE + offset,
            y: TILE_SIZE + offset,
            w: 28,
            h: 28,
            speed: 1,
            color: "#800080",
            name: "PETR",
            emoji: "ðŸ¤–",
            dead: false,
            dir: 0,
            moveTimer: 0,
          },
        ];
        bombs = [];
        explosions = [];
        walls = [];

        // Generate Map (Simple Grid)
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) {
              walls.push({ x: c * TILE_SIZE, y: r * TILE_SIZE, type: "outer" });
            } else if (r % 2 === 0 && c % 2 === 0) {
              walls.push({ x: c * TILE_SIZE, y: r * TILE_SIZE, type: "inner" });
            }
          }
        }

        gameLoop();
      }

      function placeBomb() {
        if (hero.dead) return;
        // Snap to grid
        const gx = Math.round(hero.x / TILE_SIZE);
        const gy = Math.round(hero.y / TILE_SIZE);

        // Check if bomb already exists there
        if (!bombs.some((b) => b.gx === gx && b.gy === gy)) {
          bombs.push({
            gx,
            gy,
            x: gx * TILE_SIZE,
            y: gy * TILE_SIZE,
            timer: 180, // 3 seconds at 60fps
          });
        }
      }

      function checkCollision(rect, isHero = false) {
        // Wall collisions
        for (let wall of walls) {
          if (
            rect.x < wall.x + TILE_SIZE &&
            rect.x + rect.w > wall.x &&
            rect.y < wall.y + TILE_SIZE &&
            rect.y + rect.h > wall.y
          ) {
            return true;
          }
        }
        // Bomb collisions (only if not standing on it initially - simplified: solid for now)
        // For simplicity, bombs are walkable until you step off? No, let's make them solid for enemies, walkable for hero?
        // Let's make bombs solid for everyone for simplicity, but allow hero to walk away if he just placed it.
        // Actually, standard bomberman: you can't walk through bombs.
        // But if you are ON the bomb, you are stuck? No, usually you can walk off.
        // Let's ignore bomb collision for movement for now to keep it simple and fun.
        return false;
      }

      function update() {
        if (!gameRunning) return;

        // Hero Movement
        let dx = 0;
        let dy = 0;
        if (keys["ArrowUp"]) dy = -hero.speed;
        if (keys["ArrowDown"]) dy = hero.speed;
        if (keys["ArrowLeft"]) dx = -hero.speed;
        if (keys["ArrowRight"]) dx = hero.speed;

        if (dx !== 0 || dy !== 0) {
          let newX = hero.x + dx;
          let newY = hero.y + dy;

          // Try X
          if (dx !== 0) {
            if (
              !checkCollision(
                { x: newX, y: hero.y, w: hero.w, h: hero.h },
                true
              )
            ) {
              hero.x = newX;
            } else {
              // Blocked in X. Try to align Y to nearest row.
              let gridY = Math.round(hero.y / TILE_SIZE);
              let centerY = gridY * TILE_SIZE + (TILE_SIZE - hero.h) / 2;
              let diff = centerY - hero.y;

              if (Math.abs(diff) > 0) {
                let slideDir = Math.sign(diff);
                let slideMag = Math.min(Math.abs(diff), hero.speed);

                if (
                  !checkCollision(
                    {
                      x: hero.x,
                      y: hero.y + slideDir * slideMag,
                      w: hero.w,
                      h: hero.h,
                    },
                    true
                  )
                ) {
                  hero.y += slideDir * slideMag;
                }
              }
            }
          }

          // Try Y
          if (dy !== 0) {
            if (
              !checkCollision(
                { x: hero.x, y: newY, w: hero.w, h: hero.h },
                true
              )
            ) {
              hero.y = newY;
            } else {
              // Blocked in Y. Try to align X to nearest col.
              let gridX = Math.round(hero.x / TILE_SIZE);
              let centerX = gridX * TILE_SIZE + (TILE_SIZE - hero.w) / 2;
              let diff = centerX - hero.x;

              if (Math.abs(diff) > 0) {
                let slideDir = Math.sign(diff);
                let slideMag = Math.min(Math.abs(diff), hero.speed);

                if (
                  !checkCollision(
                    {
                      x: hero.x + slideDir * slideMag,
                      y: hero.y,
                      w: hero.w,
                      h: hero.h,
                    },
                    true
                  )
                ) {
                  hero.x += slideDir * slideMag;
                }
              }
            }
          }
        }

        // Enemy AI
        enemies.forEach((en) => {
          if (en.dead) return;

          en.moveTimer--;
          if (en.moveTimer <= 0) {
            // Pick a direction towards Ivan with some randomness
            if (Math.random() < 0.7) {
              if (Math.abs(hero.x - en.x) > Math.abs(hero.y - en.y)) {
                en.dir = hero.x > en.x ? 1 : 3; // 1: Right, 3: Left
              } else {
                en.dir = hero.y > en.y ? 2 : 0; // 2: Down, 0: Up
              }
            } else {
              en.dir = Math.floor(Math.random() * 4);
            }
            en.moveTimer = 30 + Math.random() * 30;
          }

          let ex = 0,
            ey = 0;
          if (en.dir === 0) ey = -en.speed;
          if (en.dir === 2) ey = en.speed;
          if (en.dir === 3) ex = -en.speed;
          if (en.dir === 1) ex = en.speed;

          if (
            !checkCollision({ x: en.x + ex, y: en.y + ey, w: en.w, h: en.h })
          ) {
            en.x += ex;
            en.y += ey;
          } else {
            en.moveTimer = 0; // Change dir immediately
          }

          // Check collision with Hero
          if (!hero.dead && rectIntersect(hero, en)) {
            hero.dead = true;
            setTimeout(
              () => showGameOver("CAUGHT BY FRIENDS! TOO MUCH LOVE!"),
              1000
            );
          }
        });

        // Bombs
        for (let i = bombs.length - 1; i >= 0; i--) {
          let b = bombs[i];
          b.timer--;
          if (b.timer <= 0) {
            // Explode
            bombs.splice(i, 1);
            createExplosion(b.gx, b.gy);
          }
        }

        // Explosions
        for (let i = explosions.length - 1; i >= 0; i--) {
          let e = explosions[i];
          e.timer--;
          if (e.timer <= 0) {
            explosions.splice(i, 1);
          } else {
            // Check hits
            checkExplosionHit(e);
          }
        }

        // Check Win/Loss
        if (hero.dead) {
          // Handled in collision checks
        } else if (enemies.every((e) => e.dead)) {
          gameRunning = false;
          setTimeout(() => {
            level1Screen.classList.remove("active");
            successScreen.classList.add("active");
          }, 1000);
        }
      }

      function createExplosion(gx, gy) {
        let cells = [{ x: gx, y: gy }];
        // Directions: Up, Right, Down, Left
        const dirs = [
          { x: 0, y: -1 },
          { x: 1, y: 0 },
          { x: 0, y: 1 },
          { x: -1, y: 0 },
        ];

        dirs.forEach((d) => {
          for (let k = 1; k <= 3; k++) {
            // Range 3
            let tx = gx + d.x * k;
            let ty = gy + d.y * k;
            // Check wall
            if (
              walls.some(
                (w) => w.x === tx * TILE_SIZE && w.y === ty * TILE_SIZE
              )
            )
              break;
            cells.push({ x: tx, y: ty });
          }
        });

        explosions.push({ cells, timer: 30 }); // 0.5s
      }

      function checkExplosionHit(explosion) {
        explosion.cells.forEach((cell) => {
          let exRect = {
            x: cell.x * TILE_SIZE,
            y: cell.y * TILE_SIZE,
            w: TILE_SIZE,
            h: TILE_SIZE,
          };

          // Check Hero
          if (rectIntersect(exRect, hero)) {
            hero.dead = true;
            setTimeout(() => showGameOver("YOU POOED YOURSELF! OOPS!"), 1000);
          }

          // Check Enemies
          enemies.forEach((en) => {
            if (!en.dead && rectIntersect(exRect, en)) {
              en.dead = true;
            }
          });
        });
      }

      function rectIntersect(r1, r2) {
        return !(
          r2.x > r1.x + r1.w ||
          r2.x + r2.w < r1.x ||
          r2.y > r1.y + r1.h ||
          r2.y + r2.h < r1.y
        );
      }

      function draw() {
        // Clear
        ctx.fillStyle = "#111";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Walls
        walls.forEach((w) => {
          if (w.type === "outer") {
            // Outer Walls - Concrete Style
            ctx.fillStyle = "#555";
            ctx.fillRect(w.x, w.y, TILE_SIZE, TILE_SIZE);
            // Bevel
            ctx.fillStyle = "#777";
            ctx.fillRect(w.x, w.y, TILE_SIZE, 4); // Top
            ctx.fillRect(w.x, w.y, 4, TILE_SIZE); // Left
            ctx.fillStyle = "#333";
            ctx.fillRect(w.x + TILE_SIZE - 4, w.y, 4, TILE_SIZE); // Right
            ctx.fillRect(w.x, w.y + TILE_SIZE - 4, TILE_SIZE, 4); // Bottom
          } else {
            // Inner Walls - Blue/Grey Block
            ctx.fillStyle = "#4682B4"; // SteelBlue
            ctx.fillRect(w.x, w.y, TILE_SIZE, TILE_SIZE);

            // Inner detail (lighter square)
            ctx.fillStyle = "#5D9CC9";
            ctx.fillRect(w.x + 4, w.y + 4, TILE_SIZE - 8, TILE_SIZE - 8);

            // Rivets (dark corners)
            ctx.fillStyle = "#204060";
            ctx.fillRect(w.x + 2, w.y + 2, 4, 4);
            ctx.fillRect(w.x + TILE_SIZE - 6, w.y + 2, 4, 4);
            ctx.fillRect(w.x + 2, w.y + TILE_SIZE - 6, 4, 4);
            ctx.fillRect(w.x + TILE_SIZE - 6, w.y + TILE_SIZE - 6, 4, 4);
          }
        });

        // Bombs
        ctx.font = "30px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        bombs.forEach((b) => {
          ctx.fillText("ðŸ’©", b.x + TILE_SIZE / 2, b.y + TILE_SIZE / 2 + 2);
        });

        // Explosions
        explosions.forEach((e) => {
          e.cells.forEach((c) => {
            // Background flash
            ctx.fillStyle = "#8B4513";
            ctx.globalAlpha = 0.6;
            ctx.fillRect(
              c.x * TILE_SIZE,
              c.y * TILE_SIZE,
              TILE_SIZE,
              TILE_SIZE
            );
            ctx.globalAlpha = 1.0;

            // Poo Explosion
            ctx.font = "30px Arial";
            ctx.fillText(
              "ðŸ’©",
              c.x * TILE_SIZE + TILE_SIZE / 2,
              c.y * TILE_SIZE + TILE_SIZE / 2 + 2
            );

            // Small particles
            ctx.fillStyle = "#FFD700";
            ctx.fillRect(
              c.x * TILE_SIZE + Math.random() * 30,
              c.y * TILE_SIZE + Math.random() * 30,
              4,
              4
            );
            ctx.fillRect(
              c.x * TILE_SIZE + Math.random() * 30,
              c.y * TILE_SIZE + Math.random() * 30,
              4,
              4
            );
          });
        });

        // Enemies
        enemies.forEach((en) => {
          if (en.dead) return;
          // Draw Emoji
          ctx.font = "30px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(en.emoji, en.x + en.w / 2, en.y + en.h / 2 + 2);

          // Name
          ctx.fillStyle = "#fff";
          ctx.font = "10px 'Press Start 2P'";
          ctx.fillText(en.name, en.x + en.w / 2, en.y - 10);
        });

        // Hero
        if (!hero.dead) {
          // Draw Emoji
          ctx.font = "30px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(
            hero.emoji,
            hero.x + hero.w / 2,
            hero.y + hero.h / 2 + 2
          );

          ctx.fillStyle = "#fff";
          ctx.font = "10px 'Press Start 2P'";
          ctx.fillText(hero.name, hero.x + hero.w / 2, hero.y - 10);
        }
      }

      function gameLoop() {
        if (!gameRunning) return;
        update();
        draw();
        animationId = requestAnimationFrame(gameLoop);
      }
    </script>
  </body>
</html>
